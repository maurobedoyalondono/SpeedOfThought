<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpeedOfThought - Racing Programming Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        #header {
            background: linear-gradient(90deg, #e74c3c 0%, #c0392b 100%);
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 100;
        }

        #header h1 {
            font-size: 24px;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .race-status {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .status-badge {
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        /* Main Container */
        #main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left Panel - Bot Loading */
        #left-panel {
            width: 300px;
            background: rgba(44, 62, 80, 0.95);
            border-right: 2px solid #34495e;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            overflow-y: auto;
        }

        .bot-loader {
            background: rgba(255,255,255,0.08);
            border: 2px dashed #7f8c8d;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .bot-loader:hover {
            background: rgba(255,255,255,0.12);
            border-color: #95a5a6;
            transform: scale(1.02);
        }

        .bot-loader.drag-over {
            background: rgba(52, 152, 219, 0.2);
            border-color: #3498db;
        }

        .bot-loader.loaded {
            background: rgba(39, 174, 96, 0.15);
            border-color: #27ae60;
            border-style: solid;
        }

        .bot-name {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .bot-file {
            font-size: 12px;
            color: #aaa;
        }

        /* Center - Game Canvas */
        #center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, transparent 70%);
        }

        #game-canvas {
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            background: #1a1a1a;
            max-width: 100%;
            max-height: 80vh;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            display: flex;
            gap: 10px;
            background: rgba(44, 62, 80, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .control-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .control-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-btn.start {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            padding: 10px 30px;
            font-size: 16px;
        }

        .control-btn.stop {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 5px;
        }

        .speed-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid #555;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .speed-btn.active {
            background: #4444ff;
            border-color: #6666ff;
        }

        /* Right Panel - Stats & Info */
        #right-panel {
            width: 350px;
            background: rgba(44, 62, 80, 0.95);
            border-left: 2px solid #34495e;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-tabs {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-bottom: 2px solid #333;
        }

        .tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            background: transparent;
            border: none;
            color: #aaa;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .tab:hover {
            background: rgba(255,255,255,0.05);
        }

        .tab.active {
            color: white;
            background: rgba(52, 152, 219, 0.2);
            border-bottom: 2px solid #3498db;
        }

        .panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        /* Race Stats Display */
        .stat-group {
            margin-bottom: 20px;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            display: flex;
            align-items: baseline;
            gap: 5px;
        }

        .stat-unit {
            font-size: 14px;
            color: #aaa;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #44ff44 0%, #66ff66 100%);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .progress-fill.fuel {
            background: linear-gradient(90deg, #ffaa00 0%, #ffcc00 100%);
        }

        .progress-fill.boost {
            background: linear-gradient(90deg, #ff44ff 0%, #ff66ff 100%);
        }

        /* Action Log */
        #action-log {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .log-tick {
            color: #666;
            margin-right: 10px;
        }

        .log-player1 {
            color: #ff6b6b;
        }

        .log-player2 {
            color: #6b6bff;
        }

        /* Countdown Overlay */
        #countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #countdown-text {
            font-size: 120px;
            font-weight: 900;
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
            animation: pulse 1s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Winner Overlay */
        #winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .winner-card {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            border: 3px solid #3498db;
        }

        .winner-title {
            font-size: 48px;
            font-weight: 900;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #f39c12 0%, #e74c3c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .winner-name {
            font-size: 32px;
            margin-bottom: 20px;
        }

        .race-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 30px;
        }

        .race-stat {
            text-align: center;
        }

        .race-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #4444ff;
        }

        .race-stat-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #4444ff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* File Input (Hidden) */
        input[type="file"] {
            display: none;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            #left-panel { width: 250px; }
            #right-panel { width: 300px; }
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>
            üèÅ SpeedOfThought
        </h1>
        <div class="race-status">
            <div class="status-badge">Lap <span id="current-lap">1</span>/<span id="total-laps">5</span></div>
            <div class="status-badge">Tick <span id="current-tick">0</span></div>
            <div class="status-badge" id="race-state">Ready</div>
        </div>
    </div>

    <div id="main-container">
        <div id="left-panel">
            <h2>Bot Racers</h2>

            <div class="bot-loader" id="player1-loader">
                <div class="bot-name">Player 1</div>
                <div class="bot-file">Drag .js file here</div>
                <input type="file" id="player1-input" accept=".js">
            </div>

            <div class="bot-loader" id="player2-loader">
                <div class="bot-name">Player 2</div>
                <div class="bot-file">Drag .js file here</div>
                <input type="file" id="player2-input" accept=".js">
            </div>

            <button class="control-btn" id="load-examples" style="width: 100%;">
                Load Example Bots
            </button>

            <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #34495e;">
                <h3 style="margin-bottom: 15px;">Race Configuration</h3>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #95a5a6;">Number of Laps</label>
                    <input type="range" id="config-laps" min="1" max="10" value="5" style="width: 100%;">
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #7f8c8d;">
                        <span>1</span>
                        <span id="laps-value" style="color: #3498db; font-weight: bold;">5</span>
                        <span>10</span>
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #95a5a6;">Obstacle Density</label>
                    <select id="config-obstacles" style="width: 100%; padding: 5px; background: #34495e; color: white; border: 1px solid #2c3e50; border-radius: 3px;">
                        <option value="none">None (Testing)</option>
                        <option value="easy">Low (Easy)</option>
                        <option value="medium" selected>Medium</option>
                        <option value="hard">High (Hard)</option>
                    </select>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 12px; color: #95a5a6;">Fuel Stations</label>
                    <input type="range" id="config-fuel" min="1" max="10" value="1" style="width: 100%;">
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #7f8c8d;">
                        <span>1</span>
                        <span id="fuel-value" style="color: #27ae60; font-weight: bold;">1</span>
                        <span>10</span>
                    </div>
                </div>

                <button class="control-btn" id="apply-config" style="width: 100%; background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);">
                    Apply Settings
                </button>
            </div>

            <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #34495e;">
                <h3 style="margin-bottom: 15px;">Debug Info</h3>
                <div style="font-size: 11px; color: #95a5a6; font-family: monospace;">
                    <div>P1 Speed: <span id="debug-p1-speed" style="color: #3498db;">0</span> km/h</div>
                    <div>P1 Fuel Rate: <span id="debug-p1-fuel-rate" style="color: #e74c3c;">0</span> L/s</div>
                    <div>P1 Drafting: <span id="debug-p1-draft" style="color: #27ae60;">No</span></div>
                    <div style="margin-top: 5px;">P2 Speed: <span id="debug-p2-speed" style="color: #3498db;">0</span> km/h</div>
                    <div>P2 Fuel Rate: <span id="debug-p2-fuel-rate" style="color: #e74c3c;">0</span> L/s</div>
                    <div>P2 Drafting: <span id="debug-p2-draft" style="color: #27ae60;">No</span></div>
                    <div style="margin-top: 5px;">Distance Gap: <span id="debug-gap" style="color: #f39c12;">0</span> m</div>
                </div>
            </div>
        </div>

        <div id="center-panel">
            <canvas id="game-canvas" width="1000" height="600"></canvas>

            <div id="controls">
                <button class="control-btn start" id="start-btn">START RACE</button>
                <button class="control-btn stop" id="stop-btn" disabled>STOP</button>
                <button class="control-btn" id="reset-btn">RESET</button>
                <div class="speed-control">
                    <span>Speed:</span>
                    <button class="speed-btn active" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="2">2x</button>
                    <button class="speed-btn" data-speed="4">4x</button>
                </div>
                <button class="control-btn" id="debug-btn">DEBUG</button>
            </div>
        </div>

        <div id="right-panel">
            <div class="panel-tabs">
                <button class="tab active" data-tab="stats">Race Stats</button>
                <button class="tab" data-tab="log">Action Log</button>
                <button class="tab" data-tab="code">Bot Code</button>
            </div>

            <div class="panel-content" id="stats-panel">
                <h3>Player 1 üèéÔ∏è</h3>
                <div class="stat-group">
                    <div class="stat-label">Speed</div>
                    <div class="stat-value"><span id="p1-speed">0</span><span class="stat-unit">km/h</span></div>
                </div>
                <div class="stat-group">
                    <div class="stat-label">Fuel</div>
                    <div class="progress-bar">
                        <div class="progress-fill fuel" id="p1-fuel" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-group">
                    <div class="stat-label">Position</div>
                    <div class="stat-value" id="p1-position">1st</div>
                </div>

                <h3 style="margin-top: 30px;">Player 2 üèéÔ∏è</h3>
                <div class="stat-group">
                    <div class="stat-label">Speed</div>
                    <div class="stat-value"><span id="p2-speed">0</span><span class="stat-unit">km/h</span></div>
                </div>
                <div class="stat-group">
                    <div class="stat-label">Fuel</div>
                    <div class="progress-bar">
                        <div class="progress-fill fuel" id="p2-fuel" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-group">
                    <div class="stat-label">Position</div>
                    <div class="stat-value" id="p2-position">2nd</div>
                </div>
            </div>

            <div class="panel-content" id="log-panel" style="display: none;">
                <div id="action-log"></div>
            </div>

            <div class="panel-content" id="code-panel" style="display: none;">
                <pre id="bot-code-display">No bot loaded</pre>
            </div>
        </div>
    </div>

    <div id="countdown-overlay">
        <div id="countdown-text">3</div>
    </div>

    <div id="winner-overlay">
        <div class="winner-card">
            <div class="winner-title">üèÜ WINNER!</div>
            <div class="winner-name" id="winner-name">Player 1</div>
            <div class="race-stats">
                <div class="race-stat">
                    <div class="race-stat-value" id="final-time">0:00</div>
                    <div class="race-stat-label">Time</div>
                </div>
                <div class="race-stat">
                    <div class="race-stat-value" id="final-fuel">0L</div>
                    <div class="race-stat-label">Fuel Used</div>
                </div>
                <div class="race-stat">
                    <div class="race-stat-value" id="final-speed">0</div>
                    <div class="race-stat-label">Avg Speed</div>
                </div>
            </div>
            <button class="control-btn" onclick="closeWinnerOverlay()" style="margin-top: 30px;">
                NEW RACE
            </button>
        </div>
    </div>

<script>
// ====================================
// CONSTANTS AND CONFIGURATION
// ====================================

const CAR_ACTIONS = Object.freeze({
    // Speed Control Actions (mutually exclusive)
    ACCELERATE: 'ACCELERATE',      // Increase speed by 5 km/h/tick, 1.0 fuel/tick
    SPRINT: 'SPRINT',               // Increase speed by 10 km/h/tick, 2.5 fuel/tick
    COAST: 'COAST',                 // Maintain speed, 0.3 fuel/tick
    BRAKE: 'BRAKE',                 // Decrease speed by 15 km/h/tick, 0.1 fuel/tick
    BOOST: 'BOOST',                 // Max acceleration 20 km/h/tick, uses 1 boost + 3.0 fuel/tick

    // Lane Change Actions (mutually exclusive)
    CHANGE_LANE_LEFT: 'CHANGE_LANE_LEFT',   // Move one lane left over 5 ticks
    CHANGE_LANE_RIGHT: 'CHANGE_LANE_RIGHT', // Move one lane right over 5 ticks

    // Special Actions (can stack)
    JUMP: 'JUMP',                   // Jump for 10 ticks, 5.0 fuel cost
    ENTER_PIT: 'ENTER_PIT',         // Enter pit lane at next opportunity

    // Default Action
    IDLE: 'IDLE'                    // No speed change, 0.5 fuel/tick
});

const ACTION_PHYSICS = {
    ACCELERATE: {
        acceleration: 5,      // km/h per tick
        maxSpeed: 200,        // km/h
        fuelCost: 1.0,        // per tick
        tireWear: 0.001      // per tick
    },
    SPRINT: {
        acceleration: 10,
        maxSpeed: 250,
        fuelCost: 2.5,
        tireWear: 0.003
    },
    COAST: {
        acceleration: 0,
        maxSpeed: null,      // Maintains current speed
        fuelCost: 0.3,
        tireWear: 0.0001
    },
    BRAKE: {
        acceleration: -15,
        maxSpeed: null,
        fuelCost: 0.1,
        tireWear: 0.002
    },
    BOOST: {
        acceleration: 20,
        maxSpeed: 300,
        fuelCost: 3.0,
        boostCost: 1,        // Uses one boost charge
        tireWear: 0.005
    },
    IDLE: {
        acceleration: -2,     // Natural deceleration
        maxSpeed: null,
        fuelCost: 0.5,
        tireWear: 0.0001
    }
};

// ====================================
// CAR CONTROLLER
// ====================================

class CarController {
    constructor() {
        this.actions = {
            speed: null,
            lane: null,
            special: []
        };
    }

    executeAction(action) {
        const category = this.categorizeAction(action);

        switch(category) {
            case 'speed':
                this.actions.speed = action;
                break;
            case 'lane':
                this.actions.lane = action;
                break;
            case 'special':
                if (!this.actions.special.includes(action)) {
                    this.actions.special.push(action);
                }
                break;
        }
    }

    categorizeAction(action) {
        const speedActions = [
            CAR_ACTIONS.ACCELERATE,
            CAR_ACTIONS.SPRINT,
            CAR_ACTIONS.COAST,
            CAR_ACTIONS.BRAKE,
            CAR_ACTIONS.BOOST,
            CAR_ACTIONS.IDLE
        ];

        const laneActions = [
            CAR_ACTIONS.CHANGE_LANE_LEFT,
            CAR_ACTIONS.CHANGE_LANE_RIGHT
        ];

        const specialActions = [
            CAR_ACTIONS.JUMP,
            CAR_ACTIONS.ENTER_PIT
        ];

        if (speedActions.includes(action)) return 'speed';
        if (laneActions.includes(action)) return 'lane';
        if (specialActions.includes(action)) return 'special';
        return 'unknown';
    }

    getExecutionPlan() {
        return {
            speed: this.actions.speed || CAR_ACTIONS.IDLE,
            lane: this.actions.lane || null,
            special: this.actions.special
        };
    }

    reset() {
        this.actions = {
            speed: null,
            lane: null,
            special: []
        };
    }
}

// ====================================
// TRACK GENERATOR
// ====================================

class TrackGenerator {
    constructor() {
        this.trackLength = 2000; // meters
        this.lanes = 3;
        this.fuelStationCount = 1; // default
    }

    generate(seed = Math.random(), difficulty = 'medium') {
        const rng = new SeededRandom(seed);
        const segments = Math.floor(this.trackLength / 10); // 10 meter segments

        const track = {
            segments: [],
            lapDistance: this.trackLength,
            lanes: this.lanes,
            seed: seed,
            fuelStations: [],
            boostPads: [],
            obstacles: [],
            pitLaneEntry: 1850,
            pitLaneExit: 1950
        };

        // First, place fuel stations evenly
        const fuelInterval = Math.floor(segments / (this.fuelStationCount + 1));
        const fuelPositions = [];
        for (let i = 1; i <= this.fuelStationCount; i++) {
            fuelPositions.push(i * fuelInterval);
        }

        // Generate segments
        for (let i = 0; i < segments; i++) {
            const segment = {
                position: i * 10,
                type: 'normal',
                obstacles: [],
                items: [],
                grip: 0.9 + rng.next() * 0.2
            };

            // Check if this should be a fuel station
            if (fuelPositions.includes(i)) {
                segment.type = 'fuel_zone';
                segment.items.push({
                    type: 'fuel',
                    amount: 20 + rng.next() * 10,
                    lanes: [0, 1, 2]
                });
                track.fuelStations.push(i * 10);
            } else {
                // Otherwise, generate other features
                const obstacleChance = difficulty === 'none' ? 0 :
                                      difficulty === 'easy' ? 0.02 :
                                      difficulty === 'hard' ? 0.08 : 0.05;
                const boostChance = 0.02;
                const roll = rng.next();

                if (roll < obstacleChance && difficulty !== 'none') {
                    segment.type = 'obstacle';
                    segment.obstacles.push({
                        lane: Math.floor(rng.next() * 3),
                        width: 0.8,
                        jumpable: true
                    });
                    track.obstacles.push({
                        position: i * 10,
                        lanes: [segment.obstacles[0].lane]
                    });
                } else if (roll < obstacleChance + boostChance) {
                    segment.type = 'boost_zone';
                    segment.items.push({
                        type: 'boost_pad',
                        speedBonus: 20,
                        lane: Math.floor(rng.next() * 3)
                    });
                    track.boostPads.push(i * 10);
                }
            }

            track.segments.push(segment);
        }

        return track;
    }
}

class SeededRandom {
    constructor(seed) {
        this.seed = seed * 2147483647;
    }

    next() {
        this.seed = (this.seed * 1664525 + 1013904223) % 2147483647;
        return this.seed / 2147483647;
    }
}

// ====================================
// PHYSICS ENGINE
// ====================================

class PhysicsEngine {
    constructor() {
        this.CAR_LENGTH = 5;
        this.CAR_WIDTH = 0.8;
        this.DRAG_COEFFICIENT = 0.3;
        this.ROLLING_RESISTANCE = 0.015;
        this.AIR_DENSITY = 1.2;
        this.CAR_MASS = 1000; // kg
        this.DRAFT_DISTANCE_MAX = 25; // meters
        this.DRAFT_DISTANCE_MIN = 5;  // meters
    }

    tick(gameState, actions) {
        const newState = JSON.parse(JSON.stringify(gameState));
        const deltaTime = 1/60; // 60 ticks per second

        // Process each car with REAL physics
        ['player1', 'player2'].forEach((player, index) => {
            const car = newState[player];
            const action = actions[index];
            const otherPlayer = player === 'player1' ? 'player2' : 'player1';
            const opponent = newState[otherPlayer];

            // Calculate if we're drafting BEFORE applying actions
            car.isDrafting = this.calculateDrafting(car, opponent);

            // Handle lane changes
            this.handleLaneChange(car, action);

            // Handle special actions (jump, pit)
            this.handleSpecialActions(car, action);

            // Apply action to get desired engine force
            const engineForce = this.calculateEngineForce(car, action);

            // Calculate all forces
            const dragForce = this.calculateDrag(car);
            const rollingResistance = this.calculateRollingResistance(car);

            // When fuel is empty, add extra deceleration force
            let fuelEmptyForce = 0;
            if (car.fuel <= 0) {
                fuelEmptyForce = 500; // Extra resistance when engine dies
            }

            // Net force and acceleration (F = ma, so a = F/m)
            const netForce = engineForce - dragForce - rollingResistance - fuelEmptyForce;
            const acceleration = netForce / this.CAR_MASS;

            // Update velocity (v = v0 + at)
            car.speed += acceleration * deltaTime * 3.6; // convert m/s to km/h

            // Cars can't go backwards
            car.speed = Math.max(0, car.speed);

            // When fuel is empty and speed is very low, stop completely
            if (car.fuel <= 0 && car.speed < 10) {
                car.speed = 0;
                car.stopped = true;
            }

            // Update position based on speed
            this.updatePosition(car, newState.track, deltaTime);

            // Consume fuel based on ACTUAL engine output
            this.consumeFuel(car, action, engineForce, deltaTime);

            // Check collisions
            this.checkTrackCollisions(car, newState.track);
        });

        // Check car-to-car collisions
        this.checkCarCollisions(newState.player1, newState.player2);

        // Update race info
        this.updateRaceInfo(newState);

        return newState;
    }

    calculateEngineForce(car, action) {
        // No fuel = no engine force
        if (car.fuel <= 0) {
            car.engineOff = true;
            return 0;
        }
        car.engineOff = false;

        const baseForce = {
            'ACCELERATE': 3000,    // Newtons
            'SPRINT': 5000,
            'COAST': 500,          // Just enough to maintain
            'BRAKE': -4000,
            'BOOST': 7000,
            'IDLE': 0
        };

        return baseForce[action.speed] || 0;
    }

    calculateDrag(car) {
        // Drag force = 0.5 * Cd * A * œÅ * v¬≤
        const speedMs = car.speed / 3.6; // Convert km/h to m/s
        const frontalArea = 2.0; // m¬≤

        let dragCoeff = this.DRAG_COEFFICIENT;

        // Drafting reduces drag proportionally to effectiveness
        // At 100% effectiveness (5m behind): 30% drag reduction
        // At 0% effectiveness (25m behind): 0% drag reduction
        if (car.isDrafting) {
            const maxDragReduction = 0.3; // Maximum 30% reduction
            const dragReduction = maxDragReduction * car.draftEffectiveness;
            dragCoeff *= (1 - dragReduction);
        }

        return 0.5 * dragCoeff * frontalArea * this.AIR_DENSITY * speedMs * speedMs;
    }

    calculateRollingResistance(car) {
        // Rolling resistance = Crr * m * g
        const gravity = 9.81;
        let resistance = this.ROLLING_RESISTANCE * this.CAR_MASS * gravity * car.tireWear;

        // When engine is off, resistance increases significantly
        if (car.engineOff || car.fuel <= 0) {
            resistance *= 3.0; // Triple resistance when engine off (no power steering/brakes)
        }

        return resistance;
    }

    calculateDrafting(car, opponent) {
        // Check if we're behind the opponent and close enough
        const distance = opponent.position - car.position;
        const laneDiff = Math.abs(opponent.lane - car.lane);

        // Must be behind, in draft zone, and in similar lane
        if (distance > this.DRAFT_DISTANCE_MIN &&
            distance < this.DRAFT_DISTANCE_MAX &&
            laneDiff < 1) {

            // Calculate draft effectiveness (closer = stronger benefit)
            // At 5m: 100% effectiveness, at 25m: 0% effectiveness
            const draftRange = this.DRAFT_DISTANCE_MAX - this.DRAFT_DISTANCE_MIN;
            const draftEffectiveness = 1.0 - ((distance - this.DRAFT_DISTANCE_MIN) / draftRange);

            car.draftEffectiveness = draftEffectiveness;
            return true;
        }

        car.draftEffectiveness = 0;
        return false;
    }

    consumeFuel(car, action, engineForce, deltaTime) {
        if (car.fuel <= 0) {
            car.fuel = 0;
            car.fuelConsumptionRate = 0; // Track for debug
            return;
        }

        // Realistic fuel consumption rates (per tick, 60 ticks per second)
        // Target: 100L tank should last ~2-3 laps with mixed driving
        const baseFuelRates = {
            'ACCELERATE': 0.025,   // 1.5 L/sec = 90 L/min - can run ~66 seconds
            'SPRINT': 0.045,       // 2.7 L/sec = 162 L/min - can run ~37 seconds
            'COAST': 0.008,        // 0.48 L/sec = 29 L/min - can run ~200 seconds
            'BRAKE': 0.003,        // 0.18 L/sec = 11 L/min - minimal consumption
            'BOOST': 0.070,        // 4.2 L/sec = 252 L/min - can run ~24 seconds
            'IDLE': 0.005          // 0.3 L/sec = 18 L/min - very low consumption
        };

        let fuelRate = baseFuelRates[action.speed] || 0.03;

        // High speed increases fuel consumption (but not as dramatically)
        if (car.speed > 200) {
            const speedFactor = 1 + ((car.speed - 200) / 100) * 0.3; // Only 30% increase per 100km/h over 200
            fuelRate *= speedFactor;
        }

        // Drafting saves fuel proportionally to effectiveness
        if (car.isDrafting) {
            const maxFuelSavings = 0.3; // Maximum 30% fuel savings
            const fuelSavings = maxFuelSavings * car.draftEffectiveness;
            fuelRate *= (1 - fuelSavings);
        }

        // Track consumption rate for debug (convert to L/sec)
        car.fuelConsumptionRate = fuelRate * 60;

        // Apply fuel consumption (already scaled by deltaTime which is 1/60)
        car.fuel -= fuelRate;
        car.fuel = Math.max(0, car.fuel);
    }

    handleLaneChange(car, action) {
        if (action.lane === CAR_ACTIONS.CHANGE_LANE_LEFT) {
            if (car.lane > 0 && !car.changingLane) {
                car.changingLane = true;
                car.targetLane = car.lane - 1;
                car.laneChangeProgress = 0;
            }
        } else if (action.lane === CAR_ACTIONS.CHANGE_LANE_RIGHT) {
            if (car.lane < 2 && !car.changingLane) {
                car.changingLane = true;
                car.targetLane = car.lane + 1;
                car.laneChangeProgress = 0;
            }
        }

        // Update lane change progress
        if (car.changingLane) {
            car.laneChangeProgress += 0.2; // 5 ticks to complete
            if (car.laneChangeProgress >= 1) {
                car.lane = car.targetLane;
                car.changingLane = false;
                car.displayLane = car.lane;
            } else {
                // Smooth interpolation for display
                car.displayLane = car.lane + (car.targetLane - car.lane) * car.laneChangeProgress;
            }
        } else {
            car.displayLane = car.lane;
        }
    }

    handleSpecialActions(car, action) {
        // Handle jumping
        if (action.special && action.special.includes(CAR_ACTIONS.JUMP)) {
            if (!car.isJumping && car.fuel >= 5) {
                car.isJumping = true;
                car.jumpTicksRemaining = 10;
                car.fuel -= 5;
            }
        }

        // Update jump state
        if (car.isJumping) {
            car.jumpTicksRemaining--;
            if (car.jumpTicksRemaining <= 0) {
                car.isJumping = false;
            }
        }

        // Handle pit entry
        if (action.special && action.special.includes(CAR_ACTIONS.ENTER_PIT)) {
            // This would need track position checking
            // Implementation depends on track layout
        }
    }

    updatePosition(car, track, deltaTime) {
        // Update position based on speed and time
        const distancePerSecond = car.speed / 3.6; // Convert km/h to m/s

        // Inner lane is shorter! Lane 0 = 95% distance, Lane 1 = 100%, Lane 2 = 105%
        const laneDistanceMultiplier = 1.0 + (car.lane - 1) * 0.05;
        const effectiveDistance = distancePerSecond * deltaTime / laneDistanceMultiplier;

        car.position += effectiveDistance;

        // Check for lap completion
        if (car.position >= track.lapDistance) {
            car.position -= track.lapDistance;
            car.lap++;
        }

        // Update lane change
        if (car.changingLane) {
            car.laneChangeProgress += 0.2; // 5 ticks to complete
            if (car.laneChangeProgress >= 1) {
                car.lane = car.targetLane;
                car.changingLane = false;
            } else {
                // Smooth interpolation
                car.displayLane = car.lane + (car.targetLane - car.lane) * car.laneChangeProgress;
            }
        } else {
            car.displayLane = car.lane;
        }

        // Update jumping
        if (car.isJumping) {
            car.jumpTicksRemaining--;
            if (car.jumpTicksRemaining <= 0) {
                car.isJumping = false;
            }
        }
    }

    checkTrackCollisions(car, track) {
        // Check for obstacles
        const segmentIndex = Math.floor(car.position / 10);
        if (segmentIndex < track.segments.length) {
            const segment = track.segments[segmentIndex];

            // Handle obstacles - REAL collision physics
            if (segment.obstacles.length > 0 && !car.isJumping) {
                segment.obstacles.forEach((obstacle, index) => {
                    if (Math.abs(car.lane - obstacle.lane) < 0.5) {
                        // Check if we've already hit this obstacle
                        if (!car.hitObstacles) car.hitObstacles = [];
                        const obstacleId = `${segmentIndex}_${index}_${obstacle.lane}`; // More unique ID

                        // Check collision cooldown to prevent missing consecutive obstacles
                        const canCollide = !car.lastCollisionTime ||
                                         (this.tick - car.lastCollisionTime) > 5; // 5 tick cooldown

                        if (!car.hitObstacles.includes(obstacleId) && canCollide) {
                            // COLLISION! Car hits obstacle
                            car.speed *= 0.3; // Massive speed reduction
                            car.fuel -= 5; // Damage penalty

                            // Car is temporarily stunned
                            car.collisionStun = 30; // Stunned for 30 ticks (0.5 seconds)

                            // Start collision animation
                            car.collisionAnimation = 20; // Animation frames

                            // Mark obstacle as hit (car has crashed through it)
                            car.hitObstacles.push(obstacleId);
                            car.lastCollisionTime = this.tick;

                            // Clear old hit obstacles to prevent memory buildup
                            if (car.hitObstacles.length > 20) {
                                car.hitObstacles = car.hitObstacles.slice(-10);
                            }

                            // No lane change - just keep going straight
                            console.log(`CRASH! Car hit obstacle but keeps lane ${car.lane}`);
                        }
                    }
                });
            }

            // Check for fuel zones - continuous refueling while in zone
            if (segment.type === 'fuel_zone') {
                const refuelRate = 0.5; // Liters per tick while in zone (30 liters/second)
                car.fuel = Math.min(100, car.fuel + refuelRate);
            }

            // Check for boost pads - instant speed boost! (YELLOW ZONES)
            if (segment.type === 'boost_zone') {
                segment.items.forEach(item => {
                    if (item.type === 'boost_pad' && Math.abs(car.lane - item.lane) < 0.5) {
                        // Only boost if we haven't already hit this pad
                        const padId = `${segmentIndex}_${item.lane}`;
                        if (!car.usedBoostPads) car.usedBoostPads = [];

                        if (!car.usedBoostPads.includes(padId)) {
                            // Instant 20 km/h speed boost!
                            car.speed = Math.min(300, car.speed + item.speedBonus);
                            car.usedBoostPads.push(padId);
                            console.log(`Car hit boost pad! Speed: ${car.speed.toFixed(0)} km/h`);
                        }
                    }
                });
            }
        }

        // Handle collision stun
        if (car.collisionStun > 0) {
            car.collisionStun--;
            // Can't accelerate while stunned
            if (car.speed > 50) {
                car.speed -= 2; // Gradual slowdown while stunned
            }
        }

        // If car has stopped due to no fuel, it stays stopped
        if (car.stopped && car.fuel <= 0) {
            car.speed = 0;
        }
    }

    checkCarCollisions(car1, car2) {
        const distance = Math.abs(car1.position - car2.position);
        const laneDiff = Math.abs(car1.lane - car2.lane);

        if (distance < this.CAR_LENGTH && laneDiff < this.CAR_WIDTH) {
            // Cars are colliding
            if (car1.position > car2.position) {
                // Car1 is ahead, car2 gets blocked
                car2.speed = Math.min(car2.speed, car1.speed * 0.9);
            } else {
                car1.speed = Math.min(car1.speed, car2.speed * 0.9);
            }
        }

        // Check for drafting
        if (distance < 20 && distance > 5 && laneDiff < 1) {
            if (car1.position < car2.position) {
                car1.isDrafting = true;
            } else {
                car2.isDrafting = true;
            }
        } else {
            car1.isDrafting = false;
            car2.isDrafting = false;
        }
    }

    updateRaceInfo(state) {
        // Update positions
        const p1Progress = state.player1.lap * state.track.lapDistance + state.player1.position;
        const p2Progress = state.player2.lap * state.track.lapDistance + state.player2.position;

        if (p1Progress > p2Progress) {
            state.player1.racePosition = 1;
            state.player2.racePosition = 2;
        } else {
            state.player1.racePosition = 2;
            state.player2.racePosition = 1;
        }

        // Calculate relative distance for state
        state.player1.opponentDistance = state.player2.position - state.player1.position;
        state.player2.opponentDistance = state.player1.position - state.player2.position;
    }
}

// ====================================
// RENDERER
// ====================================

class Renderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.width = canvas.width;
        this.height = canvas.height;

        // Visual settings
        this.trackCenterY = this.height / 2;
        this.trackRadius = 180;
        this.laneWidth = 40;

        // Animation states
        this.animationFrame = 0;
    }

    draw(gameState, totalLaps = 5) {
        // Store totalLaps for use in drawCar
        this.totalLaps = totalLaps;

        // Clear canvas
        this.ctx.fillStyle = '#0a0a0a';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Draw track
        this.drawTrack(gameState.track);

        // Draw track features
        this.drawTrackFeatures(gameState);

        // Draw cars
        this.drawCar(gameState.player1, '#ff4444', 'P1');
        this.drawCar(gameState.player2, '#4444ff', 'P2');

        // Draw effects
        this.drawEffects(gameState);

        // Update animation frame
        this.animationFrame++;
    }

    drawTrack(track) {
        const ctx = this.ctx;

        // Draw grass
        ctx.fillStyle = '#1a4d1a';
        ctx.fillRect(0, 0, this.width, this.height);

        // Draw outer track edge
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 5;
        this.drawOval(this.trackRadius + this.laneWidth * 1.5);

        // Draw inner track edge
        this.drawOval(this.trackRadius - this.laneWidth * 1.5);

        // Draw track surface
        ctx.fillStyle = '#2a2a2a';
        ctx.beginPath();
        this.addOvalPath(this.trackRadius + this.laneWidth * 1.5);
        this.addOvalPath(this.trackRadius - this.laneWidth * 1.5, true);
        ctx.fill();

        // Draw lane lines
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.setLineDash([20, 10]);

        this.drawOval(this.trackRadius - this.laneWidth * 0.5);
        this.drawOval(this.trackRadius + this.laneWidth * 0.5);

        ctx.setLineDash([]);

        // Draw start/finish line
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(this.width / 2, this.trackCenterY - this.trackRadius - this.laneWidth * 1.5);
        ctx.lineTo(this.width / 2, this.trackCenterY - this.trackRadius + this.laneWidth * 1.5);
        ctx.stroke();
    }

    drawOval(radius) {
        const ctx = this.ctx;
        const centerX = this.width / 2;
        const centerY = this.trackCenterY;
        const stretchX = 1.8;

        ctx.beginPath();
        ctx.ellipse(centerX, centerY, radius * stretchX, radius, 0, 0, Math.PI * 2);
        ctx.stroke();
    }

    addOvalPath(radius, reverse = false) {
        const ctx = this.ctx;
        const centerX = this.width / 2;
        const centerY = this.trackCenterY;
        const stretchX = 1.8;

        if (reverse) {
            ctx.ellipse(centerX, centerY, radius * stretchX, radius, 0, Math.PI * 2, 0, true);
        } else {
            ctx.ellipse(centerX, centerY, radius * stretchX, radius, 0, 0, Math.PI * 2);
        }
    }

    drawTrackFeatures(gameState) {
        const track = gameState.track;

        // Draw fuel zones
        track.fuelStations.forEach(position => {
            const coords = this.getTrackCoordinates(position, track.lapDistance, 1);
            this.drawFuelZone(coords.x, coords.y);
        });

        // Draw boost pads
        track.boostPads.forEach(position => {
            const coords = this.getTrackCoordinates(position, track.lapDistance, 1);
            this.drawBoostPad(coords.x, coords.y);
        });

        // Draw obstacles
        track.obstacles.forEach(obstacle => {
            obstacle.lanes.forEach(lane => {
                const coords = this.getTrackCoordinates(obstacle.position, track.lapDistance, lane);
                this.drawObstacle(coords.x, coords.y);
            });
        });
    }

    drawFuelZone(x, y) {
        const ctx = this.ctx;
        ctx.fillStyle = 'rgba(68, 255, 68, 0.3)';
        ctx.fillRect(x - 30, y - 20, 60, 40);

        ctx.fillStyle = '#44ff44';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('FUEL', x, y + 5);
    }

    drawBoostPad(x, y) {
        const ctx = this.ctx;

        // Animated glow
        const glow = Math.sin(this.animationFrame * 0.1) * 0.3 + 0.7;
        ctx.fillStyle = `rgba(255, 215, 0, ${glow * 0.5})`;
        ctx.fillRect(x - 30, y - 20, 60, 40);

        // Chevrons
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 3;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(x - 15 + i * 10, y + 10);
            ctx.lineTo(x - 10 + i * 10, y - 10);
            ctx.lineTo(x - 5 + i * 10, y + 10);
            ctx.stroke();
        }
    }

    drawObstacle(x, y) {
        const ctx = this.ctx;

        // Draw cone
        ctx.fillStyle = '#ff8c00';
        ctx.beginPath();
        ctx.moveTo(x, y - 15);
        ctx.lineTo(x - 10, y + 10);
        ctx.lineTo(x + 10, y + 10);
        ctx.closePath();
        ctx.fill();

        // Stripes
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x - 5, y);
        ctx.lineTo(x + 5, y);
        ctx.stroke();
    }

    drawCar(car, color, label) {
        const coords = this.getTrackCoordinates(car.position, 2000, car.displayLane || car.lane);
        const ctx = this.ctx;

        // Jump effect
        let jumpOffset = 0;
        if (car.isJumping) {
            jumpOffset = Math.sin((10 - car.jumpTicksRemaining) / 10 * Math.PI) * 20;
        }

        // Collision animation effect
        let shakeX = 0, shakeY = 0;
        if (car.collisionAnimation && car.collisionAnimation > 0) {
            // Create shake effect
            shakeX = (Math.random() - 0.5) * 8 * (car.collisionAnimation / 20);
            shakeY = (Math.random() - 0.5) * 8 * (car.collisionAnimation / 20);
            car.collisionAnimation--;
        }

        // Car shadow
        if (jumpOffset > 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(coords.x - 15, coords.y - 10, 30, 20);
        }

        // Car body
        ctx.save();
        ctx.translate(coords.x + shakeX, coords.y - jumpOffset + shakeY);

        // Rotate based on movement
        const rotation = this.getCarRotation(car.position, 2000);
        ctx.rotate(rotation);

        // Flash red if in collision
        if (car.collisionAnimation && car.collisionAnimation > 0) {
            // Mix red with car color based on animation progress
            const flashIntensity = car.collisionAnimation / 20;
            ctx.fillStyle = `rgba(255, ${Math.floor(68 * (1-flashIntensity))}, ${Math.floor(68 * (1-flashIntensity))}, 1)`;
        } else {
            ctx.fillStyle = color;
        }
        ctx.fillRect(-15, -20, 30, 40);

        // Windows
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(-10, -15, 20, 15);
        ctx.fillRect(-10, 5, 20, 10);

        // Label
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(label, 0, 3);

        ctx.restore();

        // Draw lap counter above the car
        ctx.save();
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 3;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        const lapText = `${car.lap}/${this.totalLaps || 5}`;

        // Draw text with black outline for visibility
        ctx.strokeText(lapText, coords.x, coords.y - jumpOffset - 35);
        ctx.fillText(lapText, coords.x, coords.y - jumpOffset - 35);
        ctx.restore();

        // Drafting effect - intensity based on effectiveness
        if (car.isDrafting) {
            const opacity = 0.3 + (car.draftEffectiveness * 0.7); // 30% to 100% opacity
            ctx.strokeStyle = `rgba(0, 255, 0, ${opacity})`;
            ctx.lineWidth = 1 + (car.draftEffectiveness * 2); // 1 to 3 line width
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(coords.x - 20, coords.y - 25, 40, 50);
            ctx.setLineDash([]);
        }

        // Boost trail
        if (car.lastAction === CAR_ACTIONS.BOOST || car.lastAction === CAR_ACTIONS.SPRINT) {
            this.drawBoostTrail(coords.x, coords.y, rotation, color);
        }
    }

    drawBoostTrail(x, y, rotation, color) {
        const ctx = this.ctx;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);

        // Create gradient for trail
        const gradient = ctx.createLinearGradient(0, 20, 0, 60);
        gradient.addColorStop(0, color);
        gradient.addColorStop(0.5, 'rgba(255,255,0,0.5)');
        gradient.addColorStop(1, 'transparent');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(-5, 20);
        ctx.lineTo(-10, 60);
        ctx.lineTo(0, 55);
        ctx.lineTo(10, 60);
        ctx.lineTo(5, 20);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    drawEffects(gameState) {
        // Draw any special effects here
    }

    getTrackCoordinates(position, lapDistance, lane) {
        const progress = position / lapDistance;
        const angle = progress * Math.PI * 2 - Math.PI / 2;

        const laneOffset = (lane - 1) * this.laneWidth;
        const radius = this.trackRadius + laneOffset;

        const centerX = this.width / 2;
        const centerY = this.trackCenterY;
        const stretchX = 1.8;

        return {
            x: centerX + Math.cos(angle) * radius * stretchX,
            y: centerY + Math.sin(angle) * radius
        };
    }

    getCarRotation(position, lapDistance) {
        const progress = position / lapDistance;
        const angle = progress * Math.PI * 2;
        return angle;
    }
}

// ====================================
// BOT SANDBOX
// ====================================

class BotSandbox {
    constructor() {
        this.worker = null;
        this.timeout = 1; // 1ms timeout
    }

    async loadBot(botCode) {
        // Create worker code
        const workerCode = `
            let botInstance = null;
            let PlayerBot = null;

            // CarController for bot use
            ${CarController.toString()}

            // CAR_ACTIONS enum
            const CAR_ACTIONS = ${JSON.stringify(CAR_ACTIONS)};

            // Message handler
            self.onmessage = function(e) {
                if (e.data.type === 'INIT') {
                    try {
                        // Load the bot code
                        const botScript = e.data.botCode;

                        // Wrap the bot code to ensure PlayerBot is captured
                        const wrappedCode = botScript + '; self.PlayerBot = PlayerBot;';

                        // Execute the bot code
                        eval(wrappedCode);

                        // Now PlayerBot should be available
                        if (self.PlayerBot) {
                            PlayerBot = self.PlayerBot;
                            botInstance = new PlayerBot();
                            self.postMessage({ type: 'READY' });
                        } else {
                            throw new Error('PlayerBot class not found after evaluation');
                        }
                    } catch (error) {
                        self.postMessage({
                            type: 'ERROR',
                            error: error.message
                        });
                    }
                } else if (e.data.type === 'DECIDE') {
                    if (!botInstance) {
                        self.postMessage({
                            type: 'ERROR',
                            error: 'Bot not initialized'
                        });
                        return;
                    }

                    try {
                        const car = new CarController();
                        botInstance.decide(e.data.state, car);
                        self.postMessage({
                            type: 'DECISION',
                            actions: car.getExecutionPlan()
                        });
                    } catch (error) {
                        self.postMessage({
                            type: 'ERROR',
                            error: error.message
                        });
                    }
                }
            };
        `;

        // Create blob and worker
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerURL = URL.createObjectURL(blob);

        // Terminate old worker if exists
        if (this.worker) {
            this.worker.terminate();
        }

        this.worker = new Worker(workerURL);

        // Initialize bot
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Bot initialization timeout'));
            }, 1000);

            this.worker.onmessage = (e) => {
                clearTimeout(timeout);
                if (e.data.type === 'READY') {
                    resolve(true);
                } else if (e.data.type === 'ERROR') {
                    reject(new Error(e.data.error));
                }
            };

            this.worker.postMessage({
                type: 'INIT',
                botCode: botCode
            });
        });
    }

    async getDecision(state) {
        if (!this.worker) {
            throw new Error('Bot not loaded');
        }

        return new Promise((resolve) => {
            const timeout = setTimeout(() => {
                resolve({
                    speed: CAR_ACTIONS.IDLE,
                    lane: null,
                    special: []
                });
            }, this.timeout);

            this.worker.onmessage = (e) => {
                clearTimeout(timeout);
                if (e.data.type === 'DECISION') {
                    resolve(e.data.actions);
                } else {
                    resolve({
                        speed: CAR_ACTIONS.IDLE,
                        lane: null,
                        special: []
                    });
                }
            };

            // Send state to bot
            this.worker.postMessage({
                type: 'DECIDE',
                state: JSON.parse(JSON.stringify(state))
            });
        });
    }

    terminate() {
        if (this.worker) {
            this.worker.terminate();
            this.worker = null;
        }
    }
}

// ====================================
// RACE ENGINE
// ====================================

class RaceEngine {
    constructor() {
        this.track = null;
        this.gameState = null;
        this.bot1 = null;
        this.bot2 = null;
        this.physicsEngine = new PhysicsEngine();
        this.renderer = null;
        this.running = false;
        this.paused = false;
        this.tick = 0;
        this.speed = 1;
        this.totalLaps = 5;

        // Action log
        this.actionLog = [];
    }

    init(canvas) {
        this.renderer = new Renderer(canvas);
        this.track = new TrackGenerator().generate(Math.random(), 'medium');
        this.reset();
    }

    reset() {
        this.gameState = {
            player1: this.createCarState('player1'),
            player2: this.createCarState('player2'),
            track: this.track,
            race: {
                currentTick: 0,
                totalLaps: this.totalLaps,
                winner: null
            }
        };

        this.tick = 0;
        this.actionLog = [];
        this.running = false;
        this.paused = false;
    }

    createCarState(playerId) {
        return {
            position: 0,
            lane: playerId === 'player1' ? 1 : 1,
            lap: 1,
            speed: 0,
            fuel: 100,  // Start with full tank
            maxFuel: 100,
            boosts: 3,
            tireWear: 1.0,

            isJumping: false,
            jumpTicksRemaining: 0,
            isDrafting: false,
            draftEffectiveness: 0,
            changingLane: false,
            targetLane: 1,
            laneChangeProgress: 0,
            displayLane: 1,
            hitObstacles: [],
            usedBoostPads: [],

            racePosition: playerId === 'player1' ? 1 : 2,
            opponentDistance: 0,
            lastAction: CAR_ACTIONS.IDLE
        };
    }

    async loadBots(bot1Code, bot2Code) {
        this.bot1 = new BotSandbox();
        this.bot2 = new BotSandbox();

        await this.bot1.loadBot(bot1Code);
        await this.bot2.loadBot(bot2Code);
    }

    async start() {
        if (!this.bot1 || !this.bot2) {
            throw new Error('Bots not loaded');
        }

        this.running = true;
        this.paused = false;
        this.gameLoop();
    }

    stop() {
        this.running = false;
    }

    pause() {
        this.paused = !this.paused;
    }

    setSpeed(speed) {
        this.speed = speed;
    }

    async gameLoop() {
        if (!this.running) return;

        if (!this.paused) {
            // Get bot decisions
            const state1 = this.createBotState(this.gameState, 'player1');
            const state2 = this.createBotState(this.gameState, 'player2');

            const action1 = await this.bot1.getDecision(state1);
            const action2 = await this.bot2.getDecision(state2);

            // Log actions
            this.logActions(action1, action2);

            // Store last actions for rendering
            this.gameState.player1.lastAction = action1.speed;
            this.gameState.player2.lastAction = action2.speed;

            // Update physics
            this.gameState = this.physicsEngine.tick(this.gameState, [action1, action2]);

            // Check win conditions
            this.checkWinConditions();

            // Update tick
            this.tick++;
            this.gameState.race.currentTick = this.tick;
        }

        // Render
        this.renderer.draw(this.gameState, this.totalLaps);

        // Update UI
        this.updateUI();

        // Schedule next frame
        if (this.running) {
            setTimeout(() => this.gameLoop(), 1000 / 60 / this.speed);
        }
    }

    createBotState(gameState, playerId) {
        const myCar = gameState[playerId];
        const opponentId = playerId === 'player1' ? 'player2' : 'player1';
        const opponent = gameState[opponentId];

        // Create state for bot
        return {
            car: {
                position: myCar.position,
                lane: myCar.lane,
                lap: myCar.lap,
                speed: myCar.speed,
                fuel: myCar.fuel,
                boosts: myCar.boosts,
                isDrafting: myCar.isDrafting,
                isJumping: myCar.isJumping
            },
            opponent: {
                distance: myCar.opponentDistance,
                lane: opponent.lane,
                speed: opponent.speed,
                lap: opponent.lap
            },
            track: {
                ahead: this.getTrackAhead(myCar.position),
                lapDistance: this.track.lapDistance,
                currentLap: myCar.lap,
                totalLaps: this.totalLaps
            }
        };
    }

    getTrackAhead(position) {
        const ahead = [];
        const segmentsToCheck = 20;

        for (let i = 0; i < segmentsToCheck; i++) {
            const checkPosition = (position + i * 10) % this.track.lapDistance;
            const segmentIndex = Math.floor(checkPosition / 10);

            if (segmentIndex < this.track.segments.length) {
                const segment = this.track.segments[segmentIndex];
                ahead.push({
                    distance: i * 10,
                    type: segment.type,
                    obstacles: segment.obstacles,
                    items: segment.items
                });
            }
        }

        return ahead;
    }

    logActions(action1, action2) {
        this.actionLog.push({
            tick: this.tick,
            player1: action1.speed,
            player2: action2.speed
        });

        // Keep only last 20 entries total (10 per car shown)
        if (this.actionLog.length > 20) {
            this.actionLog.shift();
        }
    }

    checkWinConditions() {
        if (this.gameState.player1.lap > this.totalLaps) {
            this.gameState.race.winner = 'player1';
            this.running = false;
            this.onRaceEnd();
        } else if (this.gameState.player2.lap > this.totalLaps) {
            this.gameState.race.winner = 'player2';
            this.running = false;
            this.onRaceEnd();
        }
    }

    onRaceEnd() {
        // Show winner overlay
        const winner = this.gameState.race.winner;
        showWinner(winner, this.gameState, this.tick);
    }

    updateUI() {
        // Update race status
        document.getElementById('current-tick').textContent = this.tick;
        document.getElementById('current-lap').textContent =
            Math.max(this.gameState.player1.lap, this.gameState.player2.lap);

        // Update player stats
        document.getElementById('p1-speed').textContent =
            Math.round(this.gameState.player1.speed);
        document.getElementById('p1-fuel').style.width =
            this.gameState.player1.fuel + '%';
        document.getElementById('p1-position').textContent =
            this.gameState.player1.racePosition === 1 ? '1st' : '2nd';

        document.getElementById('p2-speed').textContent =
            Math.round(this.gameState.player2.speed);
        document.getElementById('p2-fuel').style.width =
            this.gameState.player2.fuel + '%';
        document.getElementById('p2-position').textContent =
            this.gameState.player2.racePosition === 1 ? '1st' : '2nd';

        // Update debug info
        if (document.getElementById('debug-p1-speed')) {
            document.getElementById('debug-p1-speed').textContent =
                Math.round(this.gameState.player1.speed);
            document.getElementById('debug-p1-fuel-rate').textContent =
                (this.gameState.player1.fuelConsumptionRate || 0).toFixed(2);
            document.getElementById('debug-p1-draft').textContent =
                this.gameState.player1.isDrafting
                    ? `YES (${Math.round(this.gameState.player1.draftEffectiveness * 100)}%)`
                    : 'No';

            document.getElementById('debug-p2-speed').textContent =
                Math.round(this.gameState.player2.speed);
            document.getElementById('debug-p2-fuel-rate').textContent =
                (this.gameState.player2.fuelConsumptionRate || 0).toFixed(2);
            document.getElementById('debug-p2-draft').textContent =
                this.gameState.player2.isDrafting
                    ? `YES (${Math.round(this.gameState.player2.draftEffectiveness * 100)}%)`
                    : 'No';

            const gap = Math.abs(this.gameState.player1.position - this.gameState.player2.position);
            document.getElementById('debug-gap').textContent = gap.toFixed(1);
        }

        // Update action log (only add new entries)
        const logDiv = document.getElementById('action-log');
        const currentLogCount = logDiv.children.length;

        // Add only new entries since last update
        for (let i = currentLogCount; i < this.actionLog.length; i++) {
            const logEntry = this.actionLog[i];
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `
                <span class="log-tick">${logEntry.tick}</span>
                <span class="log-player1">P1: ${logEntry.player1 || 'IDLE'}</span> |
                <span class="log-player2">P2: ${logEntry.player2 || 'IDLE'}</span>
            `;
            logDiv.appendChild(entry);
        }

        // Auto-scroll to bottom if there are new entries
        if (currentLogCount < this.actionLog.length) {
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Limit to last 10 entries per car (20 total) to prevent memory issues and clutter
        while (logDiv.children.length > 20) {
            logDiv.removeChild(logDiv.firstChild);
        }
    }
}

// ====================================
// UI CONTROLLER
// ====================================

class UIController {
    constructor() {
        this.raceEngine = new RaceEngine();
        this.bot1Code = null;
        this.bot2Code = null;

        this.setupEventListeners();
        this.init();
    }

    init() {
        const canvas = document.getElementById('game-canvas');
        this.raceEngine.init(canvas);
    }

    setupEventListeners() {
        // Bot loading
        this.setupBotLoader('player1');
        this.setupBotLoader('player2');

        // Control buttons
        document.getElementById('start-btn').addEventListener('click', () => this.startRace());
        document.getElementById('stop-btn').addEventListener('click', () => this.stopRace());
        document.getElementById('reset-btn').addEventListener('click', () => this.resetRace());

        // Speed controls
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                this.raceEngine.setSpeed(parseInt(e.target.dataset.speed));
            });
        });

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                const tabName = e.target.dataset.tab;
                this.switchTab(tabName);
            });
        });

        // Load examples button
        document.getElementById('load-examples').addEventListener('click', () => this.loadExampleBots());

        // Configuration controls
        const lapsSlider = document.getElementById('config-laps');
        const lapsValue = document.getElementById('laps-value');
        lapsSlider.addEventListener('input', (e) => {
            lapsValue.textContent = e.target.value;
        });

        const fuelSlider = document.getElementById('config-fuel');
        const fuelValue = document.getElementById('fuel-value');
        fuelSlider.addEventListener('input', (e) => {
            fuelValue.textContent = e.target.value;
        });

        // Apply configuration button
        document.getElementById('apply-config').addEventListener('click', () => {
            this.applyConfiguration();
        });
    }

    setupBotLoader(playerId) {
        const loader = document.getElementById(`${playerId}-loader`);
        const input = document.getElementById(`${playerId}-input`);

        // Click to open file dialog
        loader.addEventListener('click', () => input.click());

        // Drag and drop
        loader.addEventListener('dragover', (e) => {
            e.preventDefault();
            loader.classList.add('drag-over');
        });

        loader.addEventListener('dragleave', () => {
            loader.classList.remove('drag-over');
        });

        loader.addEventListener('drop', (e) => {
            e.preventDefault();
            loader.classList.remove('drag-over');

            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.js')) {
                this.loadBotFile(file, playerId);
            }
        });

        // File input change
        input.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                this.loadBotFile(file, playerId);
            }
        });
    }

    async loadBotFile(file, playerId) {
        try {
            const code = await this.readFile(file);

            // Validate bot code
            if (!code.includes('PlayerBot') || !code.includes('decide')) {
                throw new Error('Invalid bot file. Must contain PlayerBot class with decide method.');
            }

            // Store code
            if (playerId === 'player1') {
                this.bot1Code = code;
            } else {
                this.bot2Code = code;
            }

            // Update UI
            const loader = document.getElementById(`${playerId}-loader`);
            loader.classList.add('loaded');
            loader.querySelector('.bot-file').textContent = file.name;

            // Display code
            if (document.querySelector('.tab.active').dataset.tab === 'code') {
                document.getElementById('bot-code-display').textContent = code;
            }

        } catch (error) {
            alert(`Error loading bot: ${error.message}`);
        }
    }

    readFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = reject;
            reader.readAsText(file);
        });
    }

    async loadExampleBots() {
        // Simple example bots
        const simpleBot = `
class PlayerBot {
    decide(state, car) {
        // Simple bot that just accelerates and avoids obstacles

        // Check for obstacles ahead
        if (state.track.ahead[0].obstacles.length > 0) {
            car.executeAction(CAR_ACTIONS.JUMP);
        }

        // Manage fuel
        if (state.car.fuel < 20) {
            car.executeAction(CAR_ACTIONS.COAST);
        } else {
            car.executeAction(CAR_ACTIONS.ACCELERATE);
        }
    }
}`;

        const racingBot = `
class PlayerBot {
    decide(state, car) {
        // Racing bot with more advanced logic

        // Check for obstacles
        if (state.track.ahead[0].obstacles.length > 0) {
            const obstacle = state.track.ahead[0].obstacles[0];
            if (obstacle.lane === state.car.lane) {
                if (state.car.lane > 0) {
                    car.executeAction(CAR_ACTIONS.CHANGE_LANE_LEFT);
                } else {
                    car.executeAction(CAR_ACTIONS.CHANGE_LANE_RIGHT);
                }
            }
        }

        // Use boost if available and opponent is close
        if (state.car.boosts > 0 && Math.abs(state.opponent.distance) < 50) {
            car.executeAction(CAR_ACTIONS.BOOST);
        }
        // Sprint if ahead
        else if (state.opponent.distance < 0 && state.car.fuel > 50) {
            car.executeAction(CAR_ACTIONS.SPRINT);
        }
        // Conserve fuel if low
        else if (state.car.fuel < 30) {
            car.executeAction(CAR_ACTIONS.COAST);
        }
        // Normal racing
        else {
            car.executeAction(CAR_ACTIONS.ACCELERATE);
        }

        // Draft if possible
        if (state.opponent.distance > 0 && state.opponent.distance < 20) {
            if (state.opponent.lane !== state.car.lane) {
                if (state.opponent.lane > state.car.lane) {
                    car.executeAction(CAR_ACTIONS.CHANGE_LANE_RIGHT);
                } else {
                    car.executeAction(CAR_ACTIONS.CHANGE_LANE_LEFT);
                }
            }
        }
    }
}`;

        this.bot1Code = simpleBot;
        this.bot2Code = racingBot;

        // Update UI
        document.getElementById('player1-loader').classList.add('loaded');
        document.getElementById('player1-loader').querySelector('.bot-file').textContent = 'SimpleBot.js';

        document.getElementById('player2-loader').classList.add('loaded');
        document.getElementById('player2-loader').querySelector('.bot-file').textContent = 'RacingBot.js';
    }

    async startRace() {
        if (!this.bot1Code || !this.bot2Code) {
            alert('Please load both bots before starting the race!');
            return;
        }

        try {
            // Show countdown
            await this.showCountdown();

            // Load bots
            await this.raceEngine.loadBots(this.bot1Code, this.bot2Code);

            // Start race
            await this.raceEngine.start();

            // Update UI
            document.getElementById('start-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
            document.getElementById('race-state').textContent = 'Racing';

        } catch (error) {
            alert(`Error starting race: ${error.message}`);
        }
    }

    stopRace() {
        this.raceEngine.stop();

        // Terminate bot workers
        if (this.raceEngine.bot1) {
            this.raceEngine.bot1.terminate();
            this.raceEngine.bot1 = null;
        }
        if (this.raceEngine.bot2) {
            this.raceEngine.bot2.terminate();
            this.raceEngine.bot2 = null;
        }

        // Update UI
        document.getElementById('start-btn').disabled = false;
        document.getElementById('stop-btn').disabled = true;
        document.getElementById('race-state').textContent = 'Stopped';
    }

    resetRace() {
        this.raceEngine.stop();

        // Terminate bot workers
        if (this.raceEngine.bot1) {
            this.raceEngine.bot1.terminate();
            this.raceEngine.bot1 = null;
        }
        if (this.raceEngine.bot2) {
            this.raceEngine.bot2.terminate();
            this.raceEngine.bot2 = null;
        }

        // Reset the race state
        this.raceEngine.reset();

        // Redraw initial state
        if (this.raceEngine.renderer) {
            this.raceEngine.renderer.draw(this.raceEngine.gameState, this.raceEngine.totalLaps);
        }

        // Clear action log
        document.getElementById('action-log').innerHTML = '';

        // Update UI
        document.getElementById('start-btn').disabled = false;
        document.getElementById('stop-btn').disabled = true;
        document.getElementById('race-state').textContent = 'Ready';
        document.getElementById('current-tick').textContent = '0';
        document.getElementById('current-lap').textContent = '1';
        document.getElementById('total-laps').textContent = this.raceEngine.totalLaps;
    }

    async showCountdown() {
        const overlay = document.getElementById('countdown-overlay');
        const text = document.getElementById('countdown-text');

        overlay.style.display = 'flex';

        for (let i = 3; i > 0; i--) {
            text.textContent = i;
            text.style.animation = 'none';
            void text.offsetWidth; // Trigger reflow
            text.style.animation = 'pulse 1s ease-in-out';
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        text.textContent = 'GO!';
        text.style.animation = 'none';
        void text.offsetWidth;
        text.style.animation = 'pulse 1s ease-in-out';

        setTimeout(() => {
            overlay.style.display = 'none';
        }, 500);
    }

    switchTab(tabName) {
        // Update tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.tab === tabName);
        });

        // Update content
        document.getElementById('stats-panel').style.display = tabName === 'stats' ? 'block' : 'none';
        document.getElementById('log-panel').style.display = tabName === 'log' ? 'block' : 'none';
        document.getElementById('code-panel').style.display = tabName === 'code' ? 'block' : 'none';

        // Load code if code tab
        if (tabName === 'code' && this.bot1Code) {
            document.getElementById('bot-code-display').textContent = this.bot1Code;
        }
    }

    applyConfiguration() {
        // Get configuration values
        const laps = parseInt(document.getElementById('config-laps').value);
        const obstacles = document.getElementById('config-obstacles').value;
        const fuelStations = parseInt(document.getElementById('config-fuel').value);

        // Update race engine settings
        this.raceEngine.totalLaps = laps;

        // Generate new track with settings
        const trackGen = new TrackGenerator();
        trackGen.fuelStationCount = fuelStations;
        this.raceEngine.track = trackGen.generate(Math.random(), obstacles);

        // Reset the race with new settings
        this.resetRace();

        // Update UI to show new settings
        document.getElementById('total-laps').textContent = laps;

        // Show confirmation
        const btn = document.getElementById('apply-config');
        const originalText = btn.textContent;
        btn.textContent = 'Applied!';
        btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';

        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = 'linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%)';
        }, 1500);
    }
}

// ====================================
// HELPER FUNCTIONS
// ====================================

function showWinner(winner, gameState, totalTicks) {
    const overlay = document.getElementById('winner-overlay');
    overlay.style.display = 'flex';

    document.getElementById('winner-name').textContent = winner === 'player1' ? 'Player 1' : 'Player 2';
    document.getElementById('final-time').textContent = formatTime(totalTicks / 60);

    const winnerCar = gameState[winner];
    document.getElementById('final-fuel').textContent = Math.round(100 - winnerCar.fuel) + 'L';
    document.getElementById('final-speed').textContent = Math.round(winnerCar.speed) + ' km/h';
}

function closeWinnerOverlay() {
    document.getElementById('winner-overlay').style.display = 'none';
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// ====================================
// INITIALIZE APPLICATION
// ====================================

let app;

window.addEventListener('load', () => {
    app = new UIController();
});
</script>
</body>
</html>